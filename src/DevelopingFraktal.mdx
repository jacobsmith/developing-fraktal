import Editor from './editor';
import example1 from "./examples/example1.example.js"
import basicReactLoading from "./examples/basicReactLoading.example.js"

# Developing Fraktal

Fraktal is a pattern-matching library for JavaScript. It adds support for some syntax that is not normally seen in JavaScript, namely the ability to execute different blocks of code when calling the same function. It is a moderate to advanced level library - there are obviously much larger and complex packages out there - Fraktal is large enough to be useful in a real application but small enough to implement in a few hours.

## Why pattern matching?

Pattern matching is the abilitiy for function definitions themselves to declare what arguments they accept. Because of this, they can validate the shape or state of data they accept before running any execution. This leads to code that has far fewer conditionals in the code and, as such, is generally easier to reason through. It does take a bit of time to understand how to organize code utilizing pattern matching. Pattern matching also lends itself very nicely to functional programming styles as functions are the fundamental building blocks of functional languages. This is in contrast to object-oriented languages where the object is the most basic building block.

## What you'll be creating

The end result is a package that provides pattern matching ability. It will also explore Proxy objects, passing functions as arguments, data validation, and sybmols.

Example:

<Editor example={ example1 } />

As you can see above, calling `test` with different values will execute different functions. Oh, and the code above is interactive - try passing `'456'` as the argument to `app.test` and see the value update.

This same approach can be used within the context of React. For example, maybe you don't want to keep writing ternary statements to determine if data is loaded or not. With a pattern matching approach, you an use a more declarative style of programming, as well as test that code in isolation more easily.

<Editor example={ basicReactLoading } react />

As you can see, there are some additional complexities with React, primarily around how hooks are declared and executed. For now, you can copy the pattern of:

```js
    let loading, setLoading;
    const InitializeReactHooks = () => {
        [loading, setLoading] = useState(true);
    }
    app.initializeReactHooks = InitializeReactHooks;
```

This allows all functions to have access to any `hook`-related values and functions as they are declared outside of the functions themselves. Additionally, many ESLint plugins require hooks to be in a "React-component," which is to say that it validates it is in a variable with a capital letter as the first letter. So, to keep linters happy, we create the `InitializeReactHooks` constant, assign it to a variable, then pass it in to the Fraktal instance to handle. All of this will be explained in much more detail later. For now, understanding the pattern and usage is sufficient.